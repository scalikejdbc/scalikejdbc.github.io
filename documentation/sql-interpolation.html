<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <!-- Use title if it's in the page YAML frontmatter -->
    <title>SQLInterpolation - ScalikeJDBC</title>
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css"/>
    <script type="text/javascript" src="//code.jquery.com/jquery-1.11.0.min.js"></script>
    <link href="/stylesheets/all.css" rel="stylesheet" />
    <script src="/javascripts/all.js"></script>
  </head>
  <body>
    <div class="container">
    <div class="navbar" role="navigation" id="header">
      <div class="container">
        <div class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
            <li><a class="navbar-brand" href="/">ScalikeJDBC</a></li>
            <li><a href="https://groups.google.com/group/scalikejdbc-users-group">Users Group</a></li>
            <li><a href="https://github.com/scalikejdbc/scalikejdbc">GitHub</a></li>
            <li><a href="https://skinny-framework.github.io/documentation/orm.html">Skinny ORM</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="col-xs-6 pull-right" style="height:50px;">
      <gcse:searchbox-only></gcse:searchbox-only>
    </div>
      <div class="col-xs-9 left">
        <div class="content">
          <h2 id="sqlinterpolation">SQLInterpolation</h2>

<hr/>

<h3 id="whats-sqlinterpolation">What&rsquo;s SQLInterpolation</h3>

<hr/>

<p>SQLInterpolation is an SQL builder that utilizes string interpolation, available since Scala 2.10. Its usage is straightforward: simply embed values into the <code>sql&quot;&quot;</code> template without using <code>#bind</code> or <code>#bindByName</code>. This approach is quite efficient.</p>
<div class="highlight"><pre class="highlight scala"><code><span class="k">import</span> <span class="nn">scalikejdbc._</span>

<span class="k">val</span> <span class="nv">id</span> <span class="k">=</span> <span class="mi">123</span>
<span class="k">val</span> <span class="nv">member</span> <span class="k">=</span> <span class="n">sql</span><span class="s">"select id, name from members where id = ${id}"</span>
    <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">rs</span> <span class="k">=&gt;</span> <span class="nc">Member</span><span class="o">(</span><span class="n">rs</span><span class="o">)).</span><span class="py">single</span><span class="o">.</span><span class="py">apply</span><span class="o">()</span>

<span class="c1">// above code is same as follows:</span>
<span class="c1">// SQL("select id, name from members where id = {id}").bindByName("id" -&gt; id)</span>
<span class="c1">//   .map(rs =&gt; Member(rs)).single.apply()</span>
</code></pre></div>
<p>Don&rsquo;t worry, this code is secure against SQL injection attacks. <code>${id}</code> serves as a placeholder.</p>
<div class="highlight"><pre class="highlight sql"><code><span class="k">select</span> <span class="n">id</span><span class="p">,</span> <span class="n">name</span> <span class="k">from</span> <span class="n">members</span> <span class="k">where</span> <span class="n">id</span> <span class="o">=</span> <span class="o">?</span>
</code></pre></div>
<h4 id="natively-handled-types">Natively-handled types</h4>

<p>The following types are natively supported through SQL parameter binding, applicable to both SQL interpolation and explicit parameter binding:</p>

<ul>
<li>Numeric types: <code>Int</code>, <code>Short</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>java.math.{BigInt, BigDecimal}</code></li>
<li>Time and date types: <code>java.sql.{Date, Time, Timestamp}</code>, <code>java.util.Date</code>, <code>org.joda.time.{DateTime, LocalDateTime, LocalDate, LocalTime}</code>, <code>java.time.{ZonedDateTime, Instant, LocalDateTime, LocalDate, LocalTime}</code></li>
<li>Other types with a straightforward SQL correspondence: <code>java.sql.{Array, SQLXML}</code>, <code>java.io.InputStream</code> (as a binary stream)</li>
<li><code>Option</code> â€“ converted to the corresponding value for <code>Some</code> instances, and <code>null</code> for <code>None</code>.</li>
</ul>

<p>Additionally, SQL interpolation unwraps instances of <code>scala.collection.Traversable</code> and <code>java.lang.Iterable</code>, converting each element into a bound parameter separated by either backticks or commas, ensuring behavior as expected:</p>
<div class="highlight"><pre class="highlight scala"><code><span class="k">val</span> <span class="nv">ids</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="mi">123</span><span class="o">,</span> <span class="mi">124</span><span class="o">,</span> <span class="mi">125</span><span class="o">)</span>
<span class="n">sql</span><span class="s">"SELECT * FROM members WHERE id IN (${ids})"</span>
</code></pre></div>
<p>Other values are directly mapped as Objects.</p>

<hr/>

<h3 id="sqlsyntax">SQLSyntax</h3>

<hr/>

<p><code>SQLSyntax</code> is not a binding parameter but a part of the SQL. You can create a <code>SQLSyntax</code> object with sqls&quot;&ldquo; String interpolation.</p>
<div class="highlight"><pre class="highlight scala"><code><span class="k">val</span> <span class="nv">ordering</span> <span class="k">=</span> <span class="nf">if</span> <span class="o">(</span><span class="n">isDesc</span><span class="o">)</span> <span class="n">sqls</span><span class="s">"desc"</span> <span class="k">else</span> <span class="n">sqls</span><span class="s">"asc"</span>
<span class="k">val</span> <span class="nv">members</span> <span class="k">=</span> <span class="n">sql</span><span class="s">"select id, name from members order by id ${ordering} limit 10"</span>
  <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">rs</span> <span class="k">=&gt;</span> <span class="nc">Member</span><span class="o">(</span><span class="n">rs</span><span class="o">)).</span><span class="py">list</span><span class="o">.</span><span class="py">apply</span><span class="o">()</span>
</code></pre></div>
<p><code>${ordering}</code> will be directly converted to a part of SQL.</p>
<div class="highlight"><pre class="highlight sql"><code><span class="k">select</span> <span class="n">id</span> <span class="p">,</span> <span class="n">name</span> <span class="k">from</span> <span class="n">members</span> <span class="k">order</span> <span class="k">by</span> <span class="n">id</span> <span class="k">desc</span> <span class="k">limit</span> <span class="mi">10</span>
</code></pre></div>
<p>Don&rsquo;t worry again, this code is secure. <code>sqls&quot;&quot;</code> always treats external input values as binding parameters.</p>

<hr/>

<h3 id="sqlsyntaxsupport">SQLSyntaxSupport</h3>

<hr/>

<p>SQLSyntaxSupport is just shy of being an ORM. It provides a DRY method to write SQL effectively.</p>

<p>Firstly, integrate the <code>SQLSyntaxSupport[A]</code> trait into the companion object of <code>A</code>, and specify <code>tableName</code> along with the <code>#apply</code> method to map values from the <code>ResultSet</code>. The <code>ResultName[A]</code>, which may be unfamiliar, will be explained later.</p>

<p>NOTE: Utilizing case classes for entities (like <code>Group</code> and <code>GroupMember</code>) generally works well. However, if you use regular classes for entities, be mindful of entity equality. For more details, refer to: <a href="/documentation/one-to-x.html">documentation/one-to-x.html</a></p>
<div class="highlight"><pre class="highlight scala"><code><span class="k">import</span> <span class="nn">scalikejdbc._</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">Group</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">GroupMember</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
  <span class="n">groupId</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span><span class="o">,</span> <span class="n">group</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Group</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Group</span> <span class="k">extends</span> <span class="nc">SQLSyntaxSupport</span><span class="o">[</span><span class="kt">Group</span><span class="o">]</span> <span class="o">{</span>

  <span class="c1">// If you need to specify schema name, override this</span>
  <span class="c1">// def table will return sqls"public.groups" in this case</span>
  <span class="c1">// Of course, schemaName doesn't work with MySQL</span>
  <span class="k">override</span> <span class="k">val</span> <span class="nv">schemaName</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="s">"public"</span><span class="o">)</span>

  <span class="c1">// If the table name is same as snake_case'd name of this companion object,</span>
  <span class="c1">// you don't need to specify tableName explicitly.</span>
  <span class="k">override</span> <span class="k">val</span> <span class="nv">tableName</span> <span class="k">=</span> <span class="s">"groups"</span>

  <span class="c1">// If you use NamedDB for this entity, override connectionPoolName</span>
  <span class="c1">//override val connectionPoolName = 'anotherdb</span>

  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">g</span><span class="k">:</span> <span class="kt">ResultName</span><span class="o">[</span><span class="kt">Group</span><span class="o">])(</span><span class="n">rs</span><span class="k">:</span> <span class="kt">WrappedResultSet</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Group</span><span class="o">(</span><span class="nv">rs</span><span class="o">.</span><span class="py">long</span><span class="o">(</span><span class="nv">g</span><span class="o">.</span><span class="py">id</span><span class="o">),</span> <span class="nv">rs</span><span class="o">.</span><span class="py">string</span><span class="o">(</span><span class="nv">g</span><span class="o">.</span><span class="py">name</span><span class="o">))</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">GroupMember</span> <span class="k">extends</span> <span class="nc">SQLSyntaxSupport</span><span class="o">[</span><span class="kt">GroupMember</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">ResultName</span><span class="o">[</span><span class="kt">GroupMember</span><span class="o">])(</span><span class="n">rs</span><span class="k">:</span> <span class="kt">WrappedResultSet</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">GroupMember</span><span class="o">(</span><span class="nv">rs</span><span class="o">.</span><span class="py">long</span><span class="o">(</span><span class="nv">m</span><span class="o">.</span><span class="py">id</span><span class="o">),</span> <span class="nv">rs</span><span class="o">.</span><span class="py">string</span><span class="o">(</span><span class="nv">m</span><span class="o">.</span><span class="py">name</span><span class="o">),</span> <span class="nv">rs</span><span class="o">.</span><span class="py">longOpt</span><span class="o">(</span><span class="nv">m</span><span class="o">.</span><span class="py">groupId</span><span class="o">))</span>

  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">ResultName</span><span class="o">[</span><span class="kt">GroupMember</span><span class="o">],</span> <span class="n">g</span><span class="k">:</span> <span class="kt">ResultName</span><span class="o">[</span><span class="kt">Group</span><span class="o">])(</span><span class="n">rs</span><span class="k">:</span> <span class="kt">WrappedResultSet</span><span class="o">)</span> <span class="k">=</span>  <span class="o">{</span>
    <span class="nf">apply</span><span class="o">(</span><span class="n">m</span><span class="o">)(</span><span class="n">rs</span><span class="o">).</span><span class="py">copy</span><span class="o">(</span><span class="n">group</span> <span class="k">=</span> <span class="nv">rs</span><span class="o">.</span><span class="py">longOpt</span><span class="o">(</span><span class="nv">g</span><span class="o">.</span><span class="py">id</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Group</span><span class="o">(</span><span class="n">g</span><span class="o">)(</span><span class="n">rs</span><span class="o">)))</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>Use them as follows:</p>
<div class="highlight"><pre class="highlight scala"><code><span class="k">val</span> <span class="nv">id</span> <span class="k">=</span> <span class="mi">123</span>

<span class="nf">val</span> <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">g</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="nv">GroupMember</span><span class="o">.</span><span class="py">syntax</span><span class="o">(</span><span class="s">"m"</span><span class="o">),</span> <span class="nv">Group</span><span class="o">.</span><span class="py">syntax</span><span class="o">(</span><span class="s">"g"</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">groupMember</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">GroupMember</span><span class="o">]</span> <span class="k">=</span> <span class="n">sql</span><span class="s">"""
  select
    ${m.result.*}, ${g.result.*}
  from
    ${GroupMember.as(m)} left join ${Group.as(g)} on ${m.groupId} = ${g.id}
  where
    ${m.id} = ${id}
  """</span>
  <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nc">GroupMember</span><span class="o">(</span><span class="nv">m</span><span class="o">.</span><span class="py">resultName</span><span class="o">,</span> <span class="nv">g</span><span class="o">.</span><span class="py">resultName</span><span class="o">)).</span><span class="py">single</span><span class="o">.</span><span class="py">apply</span><span class="o">()</span>
</code></pre></div>
<p>While the code includes several <code>${...}</code> placeholders, I trust you can grasp their meaning. Essentially, this code executes the following SQL statement.</p>
<div class="highlight"><pre class="highlight sql"><code><span class="k">select</span>
   <span class="n">m</span><span class="p">.</span><span class="n">id</span> <span class="k">as</span> <span class="n">i_on_m</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">name</span> <span class="k">as</span> <span class="n">n_on_m</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">group_id</span> <span class="k">as</span> <span class="n">gi_on_m</span><span class="p">,</span> <span class="k">g</span><span class="p">.</span><span class="n">id</span> <span class="k">as</span> <span class="n">i_on_g</span><span class="p">,</span> <span class="k">g</span><span class="p">.</span><span class="n">name</span> <span class="k">as</span> <span class="n">n_on_g</span>
<span class="k">from</span>
  <span class="n">group_member</span> <span class="n">m</span> <span class="k">left</span> <span class="k">join</span> <span class="k">group</span> <span class="k">g</span> <span class="k">on</span> <span class="n">m</span><span class="p">.</span><span class="n">group_id</span> <span class="o">=</span> <span class="k">g</span><span class="p">.</span><span class="n">id</span>
<span class="k">where</span>
  <span class="n">m</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="o">?</span>
</code></pre></div>
<p>It&rsquo;s logical that <code>${m.result.*}</code> translates to listing all the columns, and <code>${m.camelCase}</code> converts to the corresponding snake_case column name. However, should you have any questions, I&rsquo;m here to clarify specific points in the next section.</p>

<hr/>

<h4 id="why-is-m-result-transformed-to-listing-all-the-columns">Why is ${m.result.*} transformed to listing all the columns?</h4>

<hr/>

<p>Although column names are not explicitly defined, <code>${m.result.*}</code> is converted to list all the column names. This is achieved by loading from metadata, which is cached upon the first access to the table. It&rsquo;s possible to retrieve all column names as a <code>Seq[String]</code> value via columns.</p>

<p>If you need to manually define column names or require access to multiple databases, please define column names as follows:</p>
<div class="highlight"><pre class="highlight scala"><code><span class="k">object</span> <span class="nc">GroupMember</span> <span class="k">extends</span> <span class="nc">SQLSyntaxSupport</span><span class="o">[</span><span class="kt">GroupMember</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">val</span> <span class="nv">tableName</span> <span class="k">=</span> <span class="s">"groups_members"</span>
  <span class="k">override</span> <span class="k">val</span> <span class="nv">columns</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="s">"id"</span><span class="o">,</span> <span class="s">"name"</span><span class="o">,</span> <span class="s">"group_id"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div>
<hr/>

<h4 id="why-can-we-use-undefined-methods-such-as-m-groupid">Why can we use undefined methods such as m.groupId?</h4>

<hr/>

<p>With Type Dynamic (SIP-17) available since Scala 2.10.0, you can call undefined methods like <code>m.groupId</code>. Type Dynamic functions similarly to Ruby&rsquo;s method_missing.</p>

<p><a href="https://docs.google.com/document/d/1XaNgZ06AR7bXJA9-jHrAiBVUwqReqG4-av6beoLaf3U">https://docs.google.com/document/d/1XaNgZ06AR7bXJA9-jHrAiBVUwqReqG4-av6beoLaf3U</a></p>

<p>When camel case fields are invoked, they are automatically transformed into underscore-separated column names. If a column name doesn&rsquo;t exist, an <code>InvalidColumnNameException</code> will be thrown.</p>

<p>Furthermore, the case field name must match one of the primary constructor argument names of type A in <code>SQLSyntaxSupport[A]</code>. This rule is validated during the compilation phase with the help of Scala macros.</p>

<p><a href="https://docs.scala-lang.org/overviews/macros/overview.html">https://docs.scala-lang.org/overviews/macros/overview.html</a></p>

<p>If Type Dynamic does not suit your needs, you can alternatively use <code>#field(String)</code> or <code>#column(String)</code> to specify column names explicitly. Here are four examples demonstrating this approach, all of which achieve the same result:</p>
<div class="highlight"><pre class="highlight scala"><code><span class="nv">m</span><span class="o">.</span><span class="py">groupId</span>
<span class="nv">m</span><span class="o">.</span><span class="py">field</span><span class="o">(</span><span class="s">"groupId"</span><span class="o">)</span>
<span class="nv">m</span><span class="o">.</span><span class="py">column</span><span class="o">(</span><span class="s">"group_id"</span><span class="o">)</span>
<span class="nv">m</span><span class="o">.</span><span class="py">c</span><span class="o">(</span><span class="s">"group_id"</span><span class="o">)</span>
</code></pre></div>
<p>If you prefer not to convert field names to snake-cased column names, you can set <code>useSnakeCaseColumnName</code> to false as shown below:</p>
<div class="highlight"><pre class="highlight scala"><code><span class="k">object</span> <span class="nc">UserType</span> <span class="k">extends</span> <span class="nc">SQLSyntaxSupport</span><span class="o">[</span><span class="kt">UserType</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">val</span> <span class="nv">useSnakeCaseColumnName</span> <span class="k">=</span> <span class="kc">false</span>
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div>
<p>In situations where you prefer not to expose column names to the application layer, you can override <code>nameConverters</code>. For example, if you wish to refer to the <code>service_cd</code> column as <code>serviceCode</code>, you can define a regular expression and the replacement name in <code>nameConverters</code> as follows. Since <code>nameConverters</code> operates on partial match retrieval, you can also simply specify mappings such as <code>Map(&quot;Code&quot; -&gt; &quot;cd&quot;)</code>.</p>
<div class="highlight"><pre class="highlight scala"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Event</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">serviceCode</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Event</span> <span class="k">extends</span> <span class="nc">SQLSyntaxSupport</span><span class="o">[</span><span class="kt">Event</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">val</span> <span class="nv">tableName</span> <span class="k">=</span> <span class="s">"events"</span>
  <span class="k">override</span> <span class="k">val</span> <span class="nv">columns</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="s">"id"</span> <span class="s">"name"</span><span class="o">,</span> <span class="s">"service_cd"</span><span class="o">)</span>

  <span class="c1">// specify regular expression to match</span>
  <span class="k">override</span> <span class="k">val</span> <span class="nv">nameConverters</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"^serviceCode$"</span> <span class="o">-&gt;</span> <span class="s">"service_cd"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div>
<hr/>

<h4 id="what-is-the-difference-between-m-id-m-result-id-and-m-resultname-id">What is the difference between m.id, m.result.id and m.resultName.id?</h4>

<hr/>

<p>Here&rsquo;s an explanation of the differences between <code>m.id</code>, <code>m.result.id</code>, and <code>m.resultName.id</code> based on the <code>Member.syntax(&quot;mm&quot;)</code> API:</p>

<ul>
<li><code>m.groupId</code> is generally used to reference the column directly in SQL, converting it to  <code>sqls&quot;mm.group_id&quot;</code></li>
<li><code>m.result.groupId</code> refers to the same column but with an alias for use in result processing, which is converted to <code>sqls&quot;mm.group_id as gi_on_mm&quot;</code></li>
<li><code>m.resultName</code> provides a <code>ResultName[Member]</code> object</li>
<li><code>m.resultName.groupId</code> specifically accesses the aliased column name for result processing, resulting in <code>sqls&quot;gi_on_mm&quot;</code></li>
</ul>

<p>Additionally, using <code>Member.as(m)</code> translates to <code>members m</code> in SQL, contextualizing the Member table alias.</p>

<p>If you use <code>Member.syntax()</code>, the table name is included in aliases. For example,  <code>m.result.groupId</code> becomes <code>&quot;members.group_id as gi_on_members&quot;</code>. If you set it as <code>Member.syntax(&quot;m&quot;)</code>, <code>m.result.groupId</code> translates to <code>&quot;members.group_id as gi_on_m&quot;</code>.</p>

<p>That covers all the rules of <code>SQLSyntaxSupport</code>. I believe this explanation will make the following code easier for you to understand.</p>
<div class="highlight"><pre class="highlight scala"><code><span class="k">val</span> <span class="nv">ids</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span> <span class="n">sql</span><span class="s">"select ${m.result.id} from ${Member.as(m)} where ${m.groupId} = 1"</span>
  <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="n">rs</span> <span class="k">=&gt;</span> <span class="nv">rs</span><span class="o">.</span><span class="py">long</span><span class="o">(</span><span class="nv">m</span><span class="o">.</span><span class="py">resultName</span><span class="o">.</span><span class="py">id</span><span class="o">)).</span><span class="py">list</span><span class="o">.</span><span class="py">apply</span><span class="o">()</span>
</code></pre></div>
<p>By defining the <code>#apply(ResultName[Member])</code> method, your <code>#map</code> operations become straightforward and efficient.</p>
<div class="highlight"><pre class="highlight scala"><code><span class="k">object</span> <span class="nc">Member</span> <span class="k">extends</span> <span class="nc">SQLSyntaxSupport</span><span class="o">[</span><span class="kt">Member</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">val</span> <span class="nv">tableName</span> <span class="k">=</span> <span class="s">"members"</span>
  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">ResultName</span><span class="o">[</span><span class="kt">User</span><span class="o">])(</span><span class="n">rs</span><span class="k">:</span> <span class="kt">WrappedResultSet</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">new</span> <span class="nc">Member</span><span class="o">(</span><span class="n">id</span> <span class="k">=</span> <span class="nv">rs</span><span class="o">.</span><span class="py">long</span><span class="o">(</span><span class="nv">m</span><span class="o">.</span><span class="py">id</span><span class="o">),</span> <span class="n">name</span> <span class="k">=</span> <span class="nv">rs</span><span class="o">.</span><span class="py">string</span><span class="o">(</span><span class="nv">m</span><span class="o">.</span><span class="py">name</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>
<p>You can use the above code this way:</p>
<div class="highlight"><pre class="highlight scala"><code><span class="k">val</span> <span class="nv">m</span> <span class="k">=</span> <span class="nv">Member</span><span class="o">.</span><span class="py">syntax</span><span class="o">(</span><span class="s">"m"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">members</span> <span class="k">=</span> <span class="n">sql</span><span class="s">"select ${m.result.*} from ${Member.as(m)}"</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nc">Member</span><span class="o">(</span><span class="n">m</span><span class="o">)).</span><span class="py">list</span><span class="o">.</span><span class="py">apply</span><span class="o">()</span>
<span class="c1">// select m.id as i_on_m, m.name as n_on_m from members m</span>
</code></pre></div>
<p>If you only require column names for insert, update, or delete queries, use <code>#column.{name}</code> as shown below:</p>
<div class="highlight"><pre class="highlight scala"><code><span class="k">val</span> <span class="nv">c</span> <span class="k">=</span> <span class="nv">Member</span><span class="o">.</span><span class="py">column</span>
<span class="n">sql</span><span class="s">"insert into ${Member.table} (${c.name}, ${c.birthday}) values (${name}, ${birthday})"</span>
  <span class="o">.</span><span class="py">update</span><span class="o">.</span><span class="py">apply</span><span class="o">()</span>
</code></pre></div>
<p>Since <code>#column</code> is a member of <code>SQLSyntaxSupport[A]</code>, you can utilize <code>#column</code> within the <code>Member</code> object:</p>
<div class="highlight"><pre class="highlight scala"><code><span class="k">object</span> <span class="nc">Member</span> <span class="k">extends</span> <span class="nc">SQLSyntaxSupport</span><span class="o">[</span><span class="kt">Member</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="nf">create</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">birthday</span><span class="k">:</span> <span class="kt">LocalDate</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">s</span><span class="k">:</span> <span class="kt">DBSession</span> <span class="o">=</span> <span class="nc">AutoSession</span><span class="o">)</span><span class="k">:</span> <span class="kt">Member</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">id</span> <span class="k">=</span> <span class="n">sql</span><span class="s">"insert into ${table} (${column.name}, ${column.birthday}) values (${name}, ${birthday})"</span>
      <span class="o">.</span><span class="py">updateAndReturnGeneratedKey</span><span class="o">.</span><span class="py">apply</span><span class="o">()</span>
    <span class="nc">Member</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">name</span><span class="o">,</span> <span class="n">birthday</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div>
<hr/>

<h4 id="use-case-sqlsyntaxsupport-with-table-sharding">Use Case: SQLSyntaxSupport with table sharding</h4>

<hr/>

<p>If you have multiple tables for the same entity, for example, <code>orders_2011</code>, <code>orders_2012</code>, and <code>orders_2013</code>:</p>
<div class="highlight"><pre class="highlight scala"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Order</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">productId</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">customerId</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Long</span><span class="o">],</span> <span class="n">createdAt</span><span class="k">:</span> <span class="kt">ZonedDateTime</span><span class="o">)</span>

<span class="k">class</span> <span class="nc">OrderTable</span><span class="o">(</span><span class="k">val</span> <span class="nv">year</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">SQLSyntaxSupport</span><span class="o">[</span><span class="kt">Order</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// Be careful if you build tableName with input values</span>
  <span class="c1">// ScalikeJDBC cannot protect your app from SQL injection vulnerability</span>
  <span class="k">override</span> <span class="k">val</span> <span class="nv">tableName</span> <span class="k">=</span> <span class="n">s</span><span class="s">"orders_$year"</span>

  <span class="k">def</span> <span class="nf">apply</span><span class="o">(</span><span class="n">o</span><span class="k">:</span> <span class="kt">ResultName</span><span class="o">[</span><span class="kt">Order</span><span class="o">])(</span><span class="n">rs</span><span class="k">:</span> <span class="kt">WrappedResultSet</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Order</span><span class="o">(</span>
    <span class="n">id</span>         <span class="k">=</span> <span class="nv">rs</span><span class="o">.</span><span class="py">long</span><span class="o">(</span><span class="nv">o</span><span class="o">.</span><span class="py">id</span><span class="o">),</span>
    <span class="n">productId</span>  <span class="k">=</span> <span class="nv">rs</span><span class="o">.</span><span class="py">long</span><span class="o">(</span><span class="nv">o</span><span class="o">.</span><span class="py">productId</span><span class="o">),</span>
    <span class="n">customerId</span> <span class="k">=</span> <span class="nv">rs</span><span class="o">.</span><span class="py">longOpt</span><span class="o">(</span><span class="nv">o</span><span class="o">.</span><span class="py">customerId</span><span class="o">),</span>
    <span class="n">createdAt</span>  <span class="k">=</span> <span class="nv">rs</span><span class="o">.</span><span class="py">zonedDateTime</span><span class="o">(</span><span class="nv">o</span><span class="o">.</span><span class="py">createdAt</span><span class="o">)</span>
  <span class="o">)</span>
<span class="o">}</span>
<span class="nf">val</span> <span class="o">(</span><span class="n">o2011</span><span class="o">,</span> <span class="n">o2012</span><span class="o">,</span> <span class="n">o2013</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="k">new</span> <span class="nc">OrderTable</span><span class="o">(</span><span class="mi">2011</span><span class="o">),</span> <span class="k">new</span> <span class="nc">OrderTable</span><span class="o">(</span><span class="mi">2012</span><span class="o">),</span> <span class="k">new</span> <span class="nc">OrderTable</span><span class="o">(</span><span class="mi">2013</span><span class="o">))</span>

<span class="k">val</span> <span class="nv">ordersIn2011</span> <span class="k">=</span> <span class="nc">DB</span> <span class="n">readOnly</span> <span class="o">{</span> <span class="k">implicit</span> <span class="n">s</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="nv">o</span> <span class="k">=</span> <span class="nv">o2011</span><span class="o">.</span><span class="py">syntax</span><span class="o">(</span><span class="s">"o"</span><span class="o">)</span>
  <span class="n">sql</span><span class="s">"select ${o.result.*} from ${o2011 as o} where ${o.customerId} is not null"</span>
    <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nf">o2011</span><span class="o">(</span><span class="nv">o</span><span class="o">.</span><span class="py">resultName</span><span class="o">)).</span><span class="py">list</span><span class="o">.</span><span class="py">apply</span><span class="o">()</span>
<span class="o">}</span>
<span class="nc">DB</span> <span class="n">readOnly</span> <span class="o">{</span> <span class="k">implicit</span> <span class="n">s</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="nv">o2</span> <span class="k">=</span> <span class="nv">o2012</span><span class="o">.</span><span class="py">syntax</span><span class="o">(</span><span class="s">"o"</span><span class="o">)</span>
  <span class="k">val</span> <span class="nv">ordersIn2012</span> <span class="k">=</span>
    <span class="n">sql</span><span class="s">"select ${o2.result.*} from ${o2012 as o2} where ${o2.customerId} is not null"</span>
      <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nf">o2012</span><span class="o">(</span><span class="nv">o2</span><span class="o">.</span><span class="py">resultName</span><span class="o">)).</span><span class="py">list</span><span class="o">.</span><span class="py">apply</span><span class="o">()</span>

  <span class="k">val</span> <span class="nv">o3</span> <span class="k">=</span> <span class="nv">o2013</span><span class="o">.</span><span class="py">syntax</span><span class="o">(</span><span class="s">"o"</span><span class="o">)</span>
  <span class="k">val</span> <span class="nv">ordersIn2013</span> <span class="k">=</span>
    <span class="n">sql</span><span class="s">"select ${o3.result.*} from ${o2013 as o3} where ${o3.customerId} is not null"</span>
      <span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="nf">o2013</span><span class="o">(</span><span class="nv">o3</span><span class="o">.</span><span class="py">resultName</span><span class="o">)).</span><span class="py">list</span><span class="o">.</span><span class="py">apply</span><span class="o">()</span>
<span class="o">}</span>
</code></pre></div>
<hr/>

<h4 id="use-case-working-with-22-columns-table">Use Case: Working with 22+ columns table</h4>

<hr/>

<p>NOTICE: Since Scala 2.11, you can use a case class for 22+ columns table.</p>

<p>Just use a normal class and implement the <code>EntityEquality</code> trait for one-to-many relations.</p>
<div class="highlight"><pre class="highlight scala"><code><span class="k">import</span> <span class="nn">scalikekdbc._</span>
<span class="k">import</span> <span class="nn">java.time.ZonedDateTime</span>

<span class="k">class</span> <span class="nc">HugeTable</span><span class="o">(</span>
  <span class="k">val</span> <span class="nv">column1</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span>
  <span class="k">val</span> <span class="nv">column2</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span>
  <span class="k">val</span> <span class="nv">column3</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
  <span class="k">val</span> <span class="nv">column4</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
  <span class="k">val</span> <span class="nv">column5</span><span class="k">:</span> <span class="kt">ZonedDateTime</span><span class="o">,</span>
  <span class="o">...</span>
  <span class="k">val</span> <span class="nv">column22</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span>
  <span class="k">val</span> <span class="nv">column23</span><span class="k">:</span> <span class="kt">ZonedDateTime</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">EntityEquality</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">val</span> <span class="nv">entityIdentity</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="n">column1</span><span class="o">,</span> <span class="n">column2</span><span class="o">,</span> <span class="o">...,</span> <span class="n">column23</span><span class="o">).</span><span class="py">mkString</span><span class="o">(</span><span class="s">"\t"</span><span class="o">)</span>

<span class="o">}</span>
</code></pre></div>
          <hr/>
          <div class="alert alert-warning small">
            If this webpage has a typo or something wrong, Please report or fix it. <a href="/contribution.html">How?</a>
          </div>
        </div>
      </div>

      <div class="col-xs-3 right">
        <div class="content small">
          <h5>Latest version</h5>
          <hr/>
          <p><a href="/documentation/setup.html">Setup</a></p>
          <p><a href="/documentation/configuration.html">Configuration</a></p>
          <p><a href="/documentation/connection-pool.html">Connection Pool</a></p>
          <p><a href="/documentation/operations.html">Operations</a></p>
          <p><a href="/documentation/transaction.html">Transaction</a></p>
          <p><a href="/documentation/auto-session.html">Auto Session</a></p>
          <p><a href="/documentation/sql-interpolation.html">SQLInterpolation</a></p>
          <p><a href="/documentation/query-dsl.html">QueryDSL</a></p>
          <p><a href="/documentation/one-to-x.html">One-to-x API</a></p>
          <p><a href="/documentation/auto-macros.html">Auto Macros</a></p>
          <p><a href="/documentation/query-inspector.html">Logging / Query Inspector</a></p>
          <p><a href="/documentation/reverse-engineering.html">Reverse Engineering</a></p>
          <p><a href="/documentation/testing.html">Testing</a></p>
          <p><a href="/documentation/playframework-support.html">Play Framework</a></p>
          <p><a href="/documentation/reactivestreams-support.html">Reactive Streams</a></p>
          <p><a href="/documentation/dbconsole.html">dbconsole</a></p>
          <p><a href="https://www.javadoc.io/doc/org.scalikejdbc/scalikejdbc-core_2.13/4.3.0">Core API Doc</a></p>
          <p><a href="/documentation/faq.html">FAQ</a></p>
          <p><a href="/documentation/testimonials.html">Testimonials</a></p>
          <p><a href="/contribution.html">Contribution</a></p>
          <hr/>
          <h5>Older Versions</h5>
          <hr/>
          <p><a href="/documentation/2.x/">version 2.x</a></p>
          <p><a href="/documentation/1.x/">version 1.x</a></p>
        </div>
      </div>
    </div>
    </div>
    <script type="text/javascript" src="//netdna.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <script>
(function() {
var cx = '000372347144050476309:fnw5lotlq6o';
var gcse = document.createElement('script');
gcse.type = 'text/javascript';
gcse.async = true;
gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//cse.google.com/cse.js?cx=' + cx;
var s = document.getElementsByTagName('script')[0];
s.parentNode.insertBefore(gcse, s);
})();
</script>
  </body>
</html>
